# Story 2.2: Stitch Sequence Optimization

## Status
Draft

## Story
**As a** user creating embroidery patterns,  
**I want** optimized stitch sequences that minimize thread cuts and machine time,  
**so that** my embroidery production is efficient and cost-effective with minimal thread waste.

## Acceptance Criteria
1. Path planning creates efficient routes between stitches
2. Sequences are connected where beneficial without quality loss
3. Thread cuts are minimized through intelligent sequence merging
4. Jump stitches are reduced while maintaining pattern integrity
5. Overall production time is optimized considering all factors

## Tasks / Subtasks
- [ ] Task 1: Implement TSP-based path planning (AC: 1)
  - [ ] Create PathPlanner using modified TSP algorithms for stitch sequences
  - [ ] Implement nearest neighbor heuristic as baseline algorithm
  - [ ] Add 2-opt improvement for local optimization
  - [ ] Integrate Christofides algorithm for better approximation
  - [ ] Optimize TSP solver for mobile performance constraints
  
- [ ] Task 2: Implement sequence connection optimization (AC: 2, 3)
  - [ ] Create SequenceMerger for intelligent sequence combination
  - [ ] Analyze connection feasibility between sequence endpoints
  - [ ] Implement hidden bridging stitches under existing coverage
  - [ ] Add quality assessment for merged sequences
  - [ ] Validate sequence continuity after merging operations
  
- [ ] Task 3: Implement jump stitch reduction (AC: 4)
  - [ ] Create JumpStitchOptimizer for movement minimization
  - [ ] Calculate optimal embroidery order considering thread changes
  - [ ] Implement color-based grouping to reduce thread changes
  - [ ] Add jump distance analysis and optimization
  - [ ] Generate production-ready embroidery sequence ordering
  
- [ ] Task 4: Create comprehensive optimization pipeline (AC: 5)
  - [ ] Implement SequenceOptimizer orchestrating all optimization steps
  - [ ] Add multi-objective optimization balancing time vs quality
  - [ ] Implement configurable optimization strategies
  - [ ] Generate optimization statistics and recommendations
  - [ ] Provide progress tracking for long optimization operations
  
- [ ] Task 5: Create testing and validation suite
  - [ ] Unit tests for TSP algorithms with known optimal solutions
  - [ ] Sequence merging tests with quality validation
  - [ ] Performance benchmarks for optimization speed
  - [ ] Integration tests with complete stitch generation pipeline
  - [ ] Production time estimation validation

## Dev Notes

### Optimization Algorithm Foundation
[Source: Research Analysis - Path Planning Optimization]

**TSP Algorithm Selection:**
Based on research analysis, the optimal approach combines multiple TSP techniques:

1. **Nearest Neighbor**: Fast O(n²) heuristic for initial solution
2. **2-opt Improvement**: Local optimization reducing path crossings  
3. **Christofides Algorithm**: 1.5-approximation using MST + perfect matching
4. **Match Twice and Stitch (MTS)**: Specialized for embroidery path planning

**Mathematical Framework:**
```
TSP Objective: minimize Σ distance(sequence[i].end, sequence[i+1].start)
2-opt Improvement: swap edges if distance(A,C) + distance(B,D) < distance(A,B) + distance(C,D)
Production Time: stitch_time + thread_change_time + jump_stitch_time
```

**Sequence Optimization Priority:**
1. Minimize thread changes (highest cost)
2. Minimize total jump distance
3. Minimize sequence breaks
4. Maintain quality standards

### Integration with Previous Stories
[Source: Stories 1.1, 2.1 Dependencies]

**Required Input Data:**
- **StitchSequence lists** (from Story 2.1): Grouped by color with validated continuity
- **ThreadColor mapping** (from Story 1.3): For color-based optimization grouping
- **EmbroideryParameters** (from Story 1.1): Quality vs speed trade-off settings
- **Coverage data**: For determining feasible bridging locations

**Integration Pattern:**
```dart
class SequenceOptimizer {
  OptimizationResult optimize(
    List<StitchSequence> sequences,
    EmbroideryParameters parameters,
  ) {
    // 1. Group sequences by thread color
    // 2. Optimize path within each color group
    // 3. Find optimal color change order
    // 4. Merge sequences where beneficial
    // 5. Generate final production sequence
  }
}
```

### Project Structure Integration
[Source: docs/architecture/unified-project-structure.md]

**File Locations:**
- Main optimizer: `lib/algorithm/optimization/sequence_optimizer.dart`
- Path planning: `lib/algorithm/optimization/path_planner.dart`
- Sequence merging: `lib/algorithm/optimization/sequence_merger.dart`
- Jump optimization: `lib/algorithm/optimization/jump_stitch_optimizer.dart`
- TSP algorithms: `lib/algorithm/optimization/tsp_solver.dart`

**Utility Dependencies:**
- Geometry utils: Distance calculations, point operations
- Graph algorithms: MST, perfect matching for Christofides
- Quality validation: Coverage analysis, sequence integrity

### TSP Algorithm Implementation
[Source: Research Analysis - Graph Algorithms]

**Modified TSP for Embroidery:**
```dart
class EmbroideryTSPSolver {
  List<StitchSequence> solve(List<StitchSequence> sequences) {
    // 1. Build distance matrix between sequence endpoints
    // 2. Apply nearest neighbor for initial solution
    // 3. Improve with 2-opt local search
    // 4. Validate embroidery constraints
  }
}
```

**Distance Calculation:**
```
physical_distance = euclidean_distance(seq1.end, seq2.start)
thread_change_penalty = (seq1.color != seq2.color) ? THREAD_CHANGE_COST : 0
total_cost = physical_distance + thread_change_penalty
```

**2-opt Optimization:**
```dart
bool improve2opt(List<int> tour, int i, int j) {
  double currentCost = distance(tour[i], tour[i+1]) + distance(tour[j], tour[j+1]);
  double newCost = distance(tour[i], tour[j]) + distance(tour[i+1], tour[j+1]);
  return newCost < currentCost;
}
```

### Sequence Merging Strategy
[Source: Requirements Analysis + Algorithm Research]

**Merging Feasibility Analysis:**
```dart
class SequenceMerger {
  bool canMerge(StitchSequence seq1, StitchSequence seq2) {
    // 1. Check color compatibility
    // 2. Validate connection distance
    // 3. Analyze coverage overlap for hidden bridging
    // 4. Assess quality impact
  }
}
```

**Hidden Bridging Implementation:**
- Identify areas with existing stitch coverage
- Generate bridging stitches under covered areas
- Validate bridging doesn't affect surface appearance
- Update sequence continuity validation

### Performance Optimization Requirements
[Source: docs/prd.md Technical Constraints]

**Optimization Performance Targets:**
- Optimize 500 sequences in <10 seconds
- Memory usage <256MB during optimization
- Support cancellation of long optimization operations
- Generate progress updates for user feedback

**Algorithm Scalability:**
- Use approximation algorithms for large sequence counts (>1000)
- Implement hierarchical optimization (region-based then global)
- Cache distance calculations to avoid redundant computation
- Use efficient data structures for graph operations

### Quality vs Speed Trade-offs

**Optimization Strategies:**
```dart
enum OptimizationStrategy {
  speed,    // Nearest neighbor + basic merging
  balanced, // 2-opt improvement + selective merging  
  quality,  // Christofides + comprehensive optimization
}
```

**Configuration Parameters:**
- **Speed Mode**: 80% time savings, 95% quality retention
- **Balanced Mode**: 50% time savings, 98% quality retention  
- **Quality Mode**: 100% optimization time, maximum quality

### Testing Standards
[Source: docs/architecture/testing-strategy.md]

**Test File Locations:**
- `test/algorithm/optimization/sequence_optimizer_test.dart`
- `test/algorithm/optimization/path_planner_test.dart`
- `test/algorithm/optimization/sequence_merger_test.dart`
- `test/algorithm/optimization/tsp_solver_test.dart`
- `test/algorithm/integration/optimization_integration_test.dart`

**Testing Requirements:**
- **Algorithm Tests**: TSP solver validation with known optimal solutions
- **Performance Tests**: Optimization speed within mobile constraints
- **Quality Tests**: Production time improvement validation
- **Integration Tests**: End-to-end optimization with real stitch data
- **Regression Tests**: Ensure optimization doesn't degrade quality

**Test Data Requirements:**
- Synthetic TSP problems with known optimal solutions
- Real stitch sequences from generated patterns
- Performance benchmark datasets
- Quality validation reference patterns

### Production Time Calculation

**Time Estimation Formula:**
```
total_time = stitch_time + thread_change_time + jump_stitch_time
stitch_time = stitch_count * STITCH_DURATION (100ms default)  
thread_change_time = thread_changes * CHANGE_DURATION (30s default)
jump_stitch_time = jump_distance * JUMP_SPEED (50mm/s default)
```

**Optimization Metrics:**
```dart
class OptimizationMetrics {
  final Duration estimatedTime;
  final int threadChanges;
  final double totalJumpDistance;
  final int sequenceCount;
  final double qualityScore;
  final OptimizationStrategy strategyUsed;
}
```

### Error Handling and Edge Cases

**Optimization Constraints:**
- Handle single-stitch sequences (no optimization possible)
- Manage disconnected regions (no valid bridging paths)
- Deal with color limits (too many thread changes)
- Handle memory constraints (large pattern optimization)

**Fallback Strategies:**
- Degrade to simpler algorithms under resource pressure
- Provide partial optimization results with warnings
- Maintain original sequence order if optimization fails
- Clear error reporting for constraint violations

### Integration Points and Interfaces

**Input Interface:**
- List<StitchSequence> from stitch generation
- EmbroideryParameters for optimization strategy selection
- Quality requirements and constraint specifications

**Output Interface:**
- Optimized List<StitchSequence> in production order
- OptimizationMetrics with time/quality statistics
- Production instructions for embroidery machine
- Quality assessment reports

**Progress Tracking:**
- Phase-based progress reporting (path planning, merging, ordering)
- Cancellation support for long-running optimization
- Memory usage monitoring and warnings
- Optimization quality feedback

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-09 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References  
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*To be filled by QA agent*